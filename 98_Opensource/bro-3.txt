conn.log의 필드와 타입에 대해서 알아보자. bro의 로그 필드는 이벤트를 구성하는 정보로서 대부분 어플리케이션 프로토콜의 헤더 항목과 유사하다.
conn은 네트워크 접속 관련 로그를 생성하므로 어플리케이션 헤더가 존재하지는 않는다. 
bro는 모든 로그가 출발지와 목적지의 네트워크 전송 내역을 하나의 이벤트(로그 한 줄)로 저장한다. bro에서는 이 개념을 세션이라고 한다. 
그렇기 때문에 bro는 단순히 로그 파일의 이벤트 숫자를 세는 것으로도 세션의 수를 알 수 있는 장점이 있다. 
conn.log의 필드에 대해서 상세히 알아보자. 

ts (time)    
이벤트가 최초 생성된 시간정보를 의미한다. 현재 bro가 운영중인 리눅스 서버의 시간을 가져와서 표시한다. 시간은 UNIX 타임형식이다. 
UNIX 타임형식은 epoch타임이라고 하며 1970년 1월 1일 0시 0분 0초를 기점으로 현재까지 몇초가 지났는지를 계산해서 보여준다.
사용자는 이 값에서 직접적으로 시간을 유추하기는 어렵다. 리눅스에서 date 명령어를 이용하면 사용자가 읽을 수 잇는 시간으로 변환할 수 있다. 

date -d @1533964508.833900

uid(string)
네트워크 접속을 보여주는 이벤트의 유일한 식별자이다. 18자리의 영문자와 숫자로 이루어지는 문자열로서 세션의 유일성을 구별할 수 있게 한다.
uid는 유일한 식별자이기는 하지만 모든 이벤트에서 uid가 다르게 생성되는 것은 아니다. conn.log는 네트워크 접속을 보여주는 로그다. 
bro는 네트워크 접속로그와 프로토콜별 상세 로그가 각각 다른 파일에 생성된다. 
만일 네트워크 세션이 DNS 관련 통신이라면 conn.log와 dns.log에 각각의 정보가 저장되고, 같은 UID를 가진 이벤트가 각각의 로그파일에 저장된다.

id.orig_h(addr)
id 객체는 4개의 엔드포인트 주소 정보를 포함하고 있다. 출발지 IP주소, 포트번호, 목적지 IP주소, 포트번호이다. 
IP 주소는 IPv4를 저장하고 port는 0-65535까지의 양의 정수를 저장한다.

proto(enum)
연결에 사용된 전송 계층의 프로토콜 정보를 보여준다. 

service(string)
연결에 사용된 응용 프로그램 계층의 구분자를 명시한다. 응용계층 프로토콜을 보여준다. 

duration(interval)
통신 세션이 사용한 통신 시간이다.

orig_bytes(count)
출발지에서 전송한 바이트 용량을 보여준다. 

resp_bytes(count)
목적지에서 전송한 바이트 용량을 보여준다. 

conn_state(string)
세션단위로 저장되는 이벤트의 통신 상태 정보를 보여준다.  

    S0	출발지에서 접속을 시도하였으나 후속 응답이 없음. 출발지가 syn 패킷을 전송했지만 목적지에서 응답이 없는 세션이다.
    S1	네트워크가 연결되었고 종료되지 않은 상태다. 
    S2	연결이 수립되었으며, 출발지에 의해서 종료가 진행된 상태다. 하지만 목적지로부터 응답이 없다. 
    S3	연결이 수립되었으며, 목적지에 의해서 종료가 진행된 상태다. 하지만 출발지로부터 응답이 없다.
    SF	정상적으로 연결을 맺은 다음 종료까지 된 상태다. 가장 일반적인 네트워크 송수신 상태다. 
    REJ	출발지의 연결시도를 목적지에서 거절한 상태다. 
    RSTO	연결이 수립되었고 출발지가 세션을 종료한 상태다. 즉, 출발지가 RST 패킷을 전송한 것이다. 
    RSTR	연결이 수립되었고 목적지가 세션을 종료한 상태다.
    RSTOS0	출발지에서 SYN 패킷을 전송하고 즉시 RST 패킷을 전송한 것이다. 
    RSTRH	목적지에서 SYN-ACK를 전송하고 즉시 RST 패킷을 전송한 것이다. 
    SH	출발지에서 SYN-ACK다음에 RST를 보낸 것이다. 
    SHR	목적지에서 SYN-SCK를 보낸 다음에 FIN 을 보낸 것이다. 
    OTH	SYN이 없는 트래픽 스트림의 일부 세션이다.  

local_orig(bool)        로컬 네트워크 출발 여부를 보여준다. 로컬 네트워크는 $BRO_HOME/etc/networks.cfg에서 설정한다. 
출발지 주소가 이 네트워크 범위에 속하면 이 필드의 값은 T로 설정된다.

# List of local networks in CIDR notation, optionally followed by a
# descriptive tag.
# For example, "10.0.0.0/8" or "fe80::/64" are valid prefixes.

10.0.0.0/8          Private IP space
172.16.0.0/12       Private IP space
192.168.0.0/16      Private IP space


local_resp(bool)      
로컬 네트워크가 응답했는지 여부를 보여준다.

missed_bytes(count)   
통신에서 누락된 바이트를 보여준다.

history(string)
이벤트 세션에서 패킷들이 통신한 이력을 보여준다. 

글자	의미
s	순수한 SYN 패킷
h	SYN+ACK 패킷(“handshake”)
a	순수한 ACK 패킷
d	데이터를 포함한 패킷
f	FIN 플래그가 설정된 패킷
r	RST 플래그가 설정된 패킷
c	체크섬 계산값이 틀린 패킷
i	비정상 패킷(예. SYN+RST 플래그가 동시에 설정된 것)

글자가 대문자이면 출발지에서 온 패킷이며 소문자이면 목적지에서 온 패킷이다. history 필드 값이 "ShADdFar"이라면 어떻게 해석해야 할까? 

S는 SYN패킷을 의미한다. 여기서는 대문자이므로 출발지에서 SYN 패킷을 보낸것이다. 사실 S는 항상 대문자이다. SYN은 출발지에서 최초로 전송하기 때문이다.
h는 SYN+ACK이므로 목적지에서 SYN/ACK 패킷을 전송한 것이다. 이것은 SYN에 대한 응답니다. 
A는 순수한 ACK이다. 출발지가 목적지의 SYN/ACK에 응답한 것이다. 이로서 TCP의 3-way handshake가 완성이 되었다. 
D는 데이터가 포함된 패킷이다. 대문자이므로 출발지에서 페이로드가 있는 패킷을 전송하는 것이다.
d 역시 데이터가 포함된 패킷이지만 목적지에서 전송된 패킷이다. 
F는 FIN 플래그가 포함된 패킷이다. 그러므로 데이터 전송을 완료하고 세션을 종료하려고 출발지가 FIN 패킷을 전송하였다. 
a는 ACK이다. 목적지에서 ACK를 보낸것은 출발지의 FIN에 대한 응답니다. 
r은 RST이다. 목적지에서 세션을 종료시켰다. 

히스토리를 보면 개략적으로 세션의 패킷이 어떻게 전송되었는지를 알 수 있다. 이 정보에 local_orig 정보를 함께 살펴보자. 만일 local_orig=T라면 이 history는 무엇을 의미하는가? 
내부에서 외부로 네트워크를 연결(ShA)하고 데이터를 외부로 전송(Dd)했으며 세션을 종료(Far)했다. 여러 패킷에서 데이터를 보낸다고 하더라도 D와 d 한 번만 표시된다.
이렇듯 bro는 필드의 정보만으로도 네트워크 통신 현황을 파악할 수 있는 장점이 있다.

orig_pkts(count)
전송된 패킷의 숫자

orig_ip_bytes(count)
   전송한 IP 레이어의 바이트 수, IP 헤더의 total_length 필드에서 추출된다. IP 헤더에서 나오므로 패킷의 용량을 파악하기가 더 수월하다.
resp_pkts(count)
수신된 패킷의 숫자

resp_ip_bytes(count)
   전송한 IP 레이어의 바이트 수, IP 헤더의 total_length 필드에서 추출된다. IP 헤더에서 나오므로 패킷의 용량을 파악하기가 더 수월하다.

tunnel_parents(set[string])
네트워크 세션이 터널로 연결되어 있다면 나타날 수 있는 UID 집합

네트워크 접속 로그인 conn.log에 대해서 살펴보았다. Bro는 다양한 프로토콜에 대한 정보를 상세하기 저장하기 때문에 많은 내용을 확인할 수 있다.
가장 많이 사용하는 로그들을 차례로 살펴볼 계획이다. 