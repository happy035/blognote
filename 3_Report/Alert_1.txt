경고 (Alert)

경고란 특정 조건에 맞는 검색 결과가 나타났을 경우 발생하는 Splunk 이벤트다.
보고서나 경고 역시 검색 결과를 기반으로 동작한다. 앞서 살펴본 보고서는 데이터들의 현황 파악이 주 목적이었다. 
다만 경고는 그 활용 범위가 매우 다르다.
축적하는 데이터를 저장만 하면 경고가 필요없다. 경고는 실시간으로 쌓이는 데이터를 조건에 맞게 검색하고 해당 조건에 맞는 경우 관리자에게 통보하기 위함이다.
왜 관리자에게 통보해야 할까? 그것은 관리자의 추가 행위가 필요하기 때문이다.  IT 시스템 관리자라면 시스템을 안정적으로 운용하는 것이 얼마나 어려운 일인지 알것이다.
수 백, 수 천대의 서버가 모두 동일한 환경 설정을 가지고 운영하는데도 어떤 서버는 문제가 발생하고 어떤 서버는 발생하지 않는다. 
이처럼 모든 운영중인 장비를 모니터링하는데는 막대한 인력과 자원이 소요된다. 가장 힘든것은 사람은 계속 장비를 쳐다볼 수 없다는 것이다. 
여기에서 경고의 가치가 발휘한다. (경보라는 표현을 사용하기도 한다) 

서버의 디스크 가용 공간이 없어서 정상적으로 서버가 동작하지 않을 수 있다. 시스템 메모리가 한계치에 이르러서 프로그램들이 동작하지 않을 수 있다. 
이처럼 문제가 발생하기 전에 관리자에게 문제를 알려주는 것을 경고 또는 경보라고 한다. 경고는 이 사항을 검토해야 한다라고 관리자의 주의를 끄는 것이다.

Splunk는 각종 이벤트를 수집한다. 그리고 이벤트를 효율적으로 분석할 수 있다. 분석이 가능하다는 것은 현재 상태를 진단하고 이후 상태를 예측할 수도 있다는 의미이다. 
물론 Splunk의 경고는 인공지능 수준의 미래 상황 예측이 아니다. 디스크 용량이 현재 95%라면 언젠가는 100%에 이를 것이다. 그러기 전에 관리자에게 95%라고 알려줘서 미리 대처할 수 있게 하는 것이다.
* Splunk 기계학습(Machine Learning)은 대시보드 항목이 완료되면 다뤄볼까 한다.

경고는 다양하게 설정할 수 있다. 우선 경고를 얻을 수 있는 검색어를 작성해보자. 
웹서버에서 관리자에게 경고를 알려줄 수 있는 것이 무엇이 있을까? Splunk는 어떤 항목이 중요한지 알려주지 않는다. 
경고를 생성하는 항목은 철저하게 관리자의 재량이다. 경고 항목은 철저하게 수집하는 데이터의 성격을 잘 이해해야 한다.
웹 서버는 사용자의 요청을 제공하는 역할을 수행한다. 이 로그는 사용자가 요청한 내역에 웹 서버가 어떤 서비스를 제공했는지 모두 로그에 저장한다. 
가장 눈여겨 볼 것은 웹 서버 상태코드이다. 상태코드란 사용자의 요청에 웹서버가 실행한 내역을 코드로 분류한 것이다. 

웹서버 표준 문서는 여기(http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)에서 찾아볼 수 있다. 

상태코드는 100, 200, 300, 400, 500계열로 구분되며 오류에 관련된 항목은 400과 500계열이다. 
그러므로 상태코드에서 400과 500을 모니터링하는 것으로도 서버의 안정성을 어느정도 확인할 수 있다. 어느정도라고 얘기하는 이유는 이 두 가지만이 완벽한 것은 아니라는 말이다. 
간단한 예를 들어보자. 400계열과 500계열은 웹 서버가 클라이언트에게 정상적인 서비스를 제공하지 못했다는 의미이다.
하지만 공격자들이 공격으로 데이터를 탈취해가는 SQL Injection은 공격이 성공하면 정상을 나타내는 상태코드인 200이 나타난다. 
웹서버 공격 성공은 상태코드가 200으로 나타난다. 하지만 성공하기 전에 공격자는 무수한 400계열과 500계열을 발생시켜 취약점을 찾은 후에 공격을 성공시킨다.
아.. 웹 서버가 너무 약해서 금방 공격이 성공하는 경우도 있다. 

서론이 길었지만 우리는 400계열과 500계열을 경고로 작성해보자. 우선 500을 먼저 설정해보자. 
500은 Internal Server Error을 나타내는 것으로 대부분 웹 어플리케이션이 비정상적으로 동작할 때 발생한다.
우선 어떤 상태코드가 이벤트에 존재하는지 먼저 살펴보자. 

index=book sourcetype="access_combined_wcookie" 
| top showperc=f status

alert_1.png

top 명령어는 지정한 필드의 개수가 많은 순서대로 나열한다. 기본값은 상위 10개를 보여준다. showperc=f는 해당 값이 차지하는 비율을 보여주지 않을 때 사용한다.
만일 20개를 보고 싶고 값의 비율을 알고 싶다면 검색어를 아래와 같이 작성한다. 

index=book sourcetype="access_combined_wcookie" 
| top limit=20 showperc=t status

사실 showperc=t는 입력하지 않아도 된다. 기본값이 비율을 보여주는 것이기 때문이다.
생각보다 많은 상태코드들이 샘플 이벤트에 존재한다. 그럼 이제 상태코드가 500인것만을 추출해보자.

alert_2.png

이벤트 전체를 살펴보는 것이 정확한 정보를 제공하지만 직관적인 정보를 제공하는 것이 중요하다. 경고에는 간략한 정보를 제공하고 상세 분석은 직접 검색해서 분석할 수 있기 때문이다. 
이벤트에서 오류가 발생할 때 관리자에게 필요한 정보는 어떤 출발지에서 오류를 발생시키는지, 그리고 어떤 서버 자원이 오류에 노출되었는지를 찾아야 한다. 
출발지를 나타내는 필드명은 clientip이며 서버 자원은 uri에서 찾을 수 있다. 다음의 검색어를 실행시킨다. 

index=book sourcetype="access_combined_wcookie" status=500 
| table clientip, uri

alert_3.png

table 명령어는 모든 정보를 테이블 형식으로 나열하기 때문에 이 정보를 분석하기는 어렵다. 한 가지를 더 생각해보자. 
많은 500코드를 발생시키는 출발지는 어떤 것일까? 출발지 IP를 개수별로 찾아보자.

index=book sourcetype="access_combined_wcookie" status=500 
| stats count by clientip
| sort - count

alert_4_stat.png
alert_5_top.png

이제 어떤 출발지 IP가 많은 오류를 발생시키는 줄 알았다. 그러면 어떤 서비스 자원에서 500 오류가 발생할까? 

index=book sourcetype="access_combined_wcookie" status=500 
| top showperc=f limit=20 uri

alert_6_top.png

500 오류가 발생한 uri별 개수는 2개가 넘지 않는다. 하지만 앞에서 살펴본 특정 clientip는 19개도 오류가 있었다. 
이것은 무슨 의미일까? 하나의 clientip가 여러개의 uri 오류를 일으켰다고 봐야 할 것이다.
이 두가지를 동시에 볼 수 있는 검색어를 만들어보자. 

index=book sourcetype="access_combined_wcookie" status=500 
| stats count(clientip) as cIP values(uri) as lUri by clientip 
| sort - cIP

count(clientip) as cIP # clientip의 개수를 센다음 cIP라는 필드명에 값을 할당한다.
values(uri) as lUri    # uri의 고유 목록을 나열하고 lUri라는 필드명에 값을 할당한다.
by clientip    # 모든 계산을 clientip를 기준으로 계산한다.
sort - cIP     # cIP 필드값을 기준으로 역순으로 정렬한다.

이 검색의 결과는 다음과 같다. 
alert_7_stats.png

values(uri) 줄 개수와 clientip의 개수가 맞지 않을 수 있다. 그 이유는 values()함수는 중복값이 있는 경우 이를 제외하고 유일한 목록을 나열하기 때문이다.
만일 중복값이 아닌 모든 값의 목록을 얻고 싶다면 list()함수를 사용하면 된다. 

어쩌다 보니 경보가 아니라 경보 이전의 검색만을 길게 설명하였다. 자세한 경보 설정은 이제까지 살펴본 검색 결과를 가지고 다음에 자세히 설명하겠다. 